---
title: "Časovne vrste seminar"
author: "Brina Pirc in Anja Trobec"
date: "Maj 2022"
output:
  html_document:
    fig_caption: no
    toc: no
    toc_depth: '3'
params:
  printcode: no
  printresults: hide
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=params$printcode, results=params$printresults, warning=FALSE, message=FALSE)
library(dplyr)
library(tseries)
library(LSTS)
library(forecast)
library("TTR")
```


```{r, echo=TRUE, eval=TRUE, results="markup", echo=FALSE}
setwd("C:/Users/aanja/OneDrive/Dokumenti/fmf/magisterij/časovne vrste/seminar/Time-series")

```


<h1> DATOTEKA A </h1>

1. Narišite graf in komentirajte, ali se iz njega vidi kakšen trend ali sezonskost.
```{r, echo=TRUE, eval=TRUE, results="markup",echo=FALSE}
file2 <- file("A09tri.txt")
str_data2 <- readLines(file2)
data2 <- as.numeric(unlist(strsplit(str_data2, " ")))
x <- ts(data2)

# vsa opazovanja:
plot(x, main="Časovna vrsta podatki A, vsa opazovanja", ylim = c(-100,2000), type='l')

# le prvih 100:
plot(x, main="Časovna vrsta podatki A, le prvih 100 opazovanj", xlim=c(0,100), ylim = c(-100,2000), type='l')

komentar <- paste('Ne opazimo trenda, opazimo pa sezonskost.')
print(komentar)

```

2. Odstranite morebiten trend in sezonskost z metodami, uporabljenimi pri tečaju:
(zaporedno) diferenciranje, logaritmiranje, neposredna ocena sezonskih komponent,
polinomski trend stopnje največ 3 ali prileganje periodične funkcije (ali kakšna kombinacija teh metod).
Potem ko odstranite morebiten trend, narišite tudi surovi in zglajeni periodogram ter komentirajte, ali se vidi kakšna sezonskost in kakšna naj bi bila perioda.

REŠEVANJE:
logaritmiranja ne moremo uporabiti, ker imamo negativne podatke
diferenciranje:

```{r, echo=TRUE, eval=TRUE, results="markup",echo=FALSE}
#Opazujmo diference
d <- diff(x)
plot(d, main='Diference časovne vrste A', xlim = c(0,100), ylab=expression(paste(nabla,x[t]," [pp]")),type='l')

abline(h=mean(d),col="blue")
abline(h=c(mean(d)-sd(d),mean(d)+sd(d)),col="blue",lty="dotted")

# periodogram(x)

# BRINA, ZDEJ TO DELA, NISVA IMELI PRAVEGA PAKETA :D
perioda <-  periodogram(x)$lambda[which.max(periodogram(x)$periodogram)] 
perioda2 <- periodogram(x)$periodogram[208] #ni statistično značilna!
# perioda3 <- periodogram(x)$periodogram[206]
# perioda4 <- periodogram(x)$periodogram[209]
# perioda5 <- periodogram(x)$periodogram[205]  

t <- time(x)
mod.H <- lm(x ~  I(sin(perioda*t)) + I(cos(perioda*t)) + I(sin(perioda2*t)) + I(cos(perioda2*t)))
summary(mod.H)

x.fit <- mod.H$fitted.values
x.res <- mod.H$residuals

x.fit <- ts(x.fit,start=start(x),frequency=frequency(x))
x.res <- ts(x.res,start=start(x),frequency=frequency(x))

par(mfrow=c(1,1))
plot(x, type='l', main='Časovna vrsta A')
points(x.fit,col="red",type="o",pch=16,cex=0.5)
par(mfrow=c(1,1))
plot(x, type='l', xlim=c(0,100), main='Časovna vrsta A, prvih 100')
points(x.fit,col="red",type="o",pch=16,cex=0.5)

komentar <- paste('PROBLEM- bolj gost x.fit bi potrebovali, dobiva špice, ker imava premalo točk,
kako zgostiti število točk?')
print(komentar)


# POTENCIALNA REŠITEV:
# A lahko naredimo periodogram na razlikah, ker pride ful lepše!!

perioda <-  periodogram(d)$lambda[which.max(periodogram(d)$periodogram)] 
perioda2 <- periodogram(d)$periodogram[208] #ni statistično značilna!
# perioda3 <- periodogram(x)$periodogram[206]
# perioda4 <- periodogram(x)$periodogram[209]
# perioda5 <- periodogram(x)$periodogram[205]  

t <- time(d)
mod.H2 <- lm(d ~  I(sin(perioda*t)) + I(cos(perioda*t)))
summary(mod.H2)

d.fit <- mod.H2$fitted.values
d.res <- mod.H2$residuals

d.fit <- ts(d.fit,start=start(d),frequency=frequency(d))
d.res <- ts(d.res,start=start(d),frequency=frequency(d))

par(mfrow=c(1,1))
plot(d, type='l')
points(d.fit,col="red",type="o",pch=16,cex=0.5)
par(mfrow=c(1,1))
plot(d, type='l', xlim=c(0,100))
points(d.fit,col="red",type="o",pch=16,cex=0.5)

```

```{r, echo=TRUE, eval=TRUE, results="markup", echo=FALSE}
# # DRUG PRISTOP:
# library(TSA)
# x.p <- periodogram(x)
# order(x.p$spec,decreasing=TRUE) #these are heights
# 
# # Top frequencies at 216 215 223 222
# #what are those frequencies?
# 
# x.p$freq[c(216,215,223,222)]
# 
# # Raw periodogram - we take frequences
# # sin(2*pi*0.2500000*t) + cos(2*pi*0.2500000*t)
# # sin(2*pi*0.2488426*t) + cos(2*pi*0.2488426*t)
# # sin(2*pi*0.2581019*t) + cos(2*pi*0.2581019*t)
# # sin(2*pi*0.2569444*t) + cos(2*pi*0.2569444*t)
# 
# #what are the periods of those?
# 1/x.p$freq[c(216,215,223,222)]
# 
# # Smoothed periodogram
# # ====================
# # Raw periodogram as a density estimator (identical numbers)
# 
# spectrum(x,
#          log="no",
#          demean=TRUE,
#          detrend=FALSE,
#          taper=0,
#          lwd = 2)
# spectrum(x,
#          log="no",
#          demean=TRUE,
#          detrend=FALSE,
#          taper=0,
#          lwd = 2,
#          xlim=c(0.22,0.28))
# 
# # we have to smooth it! By using kernels!
# 
# # Smoothing kernels
# kernel(coef='daniell',m=2) #2 steps to the left and 2 steps to the right
# kernel(coef='modified.daniell',m=1) #1 step left & 1 step right
# 
# # Iterating smoothing kernels
# kernel(coef='daniell', m=c(1,1))
# kernel(coef='modified.daniell', m=c(1,1))
# 
# # Visually choose kernel (Command spec.pgram does the same!)
# spectrum(x,
#          kernel=kernel(coef='modified.daniell', m=2),
#          log="no",
#          demean=TRUE,
#          detrend=FALSE,
#          taper=0,
#          xlim=c(0.22,0.28))
# 
# spectrum(x,
#          spans=7, # L = 2m+1 for Modified Daniell kernel (default); "rounds up" if even
#          log="no",
#          demean=TRUE,
#          detrend=FALSE,
#          taper=0,
#          xlim=c(0.22,0.28))
# 
# x.sp <- spectrum(d,
#                  kernel=kernel(coef='daniell', m=c(3,3)),
#                  log="no",
#                  demean=TRUE,
#                  detrend=FALSE,
#                  taper=0,
#                  lwd = 1.5,
#                  xlim=c(0.22,0.28))
# 
# order(x.sp$spec,decreasing = TRUE)
# 
# # Top frequencies at 216 217 215 218
# 
# #SM. Periodogram
# x.sp$freq[c(216,217,215,218)]
# 
# # Period
# 1/x.sp$freq[c(216,217,215,218)]
# 
# # Harmonic regression
# # ===================
# library(TSA)
# plot(x, ylab=expression(paste(nabla,x[t]," [pp]")))
# 
# tt <- time(x)
# 
# mod.H1 <- lm(x ~ I(sin(2*pi*tt*4)) + I(cos(2*pi*tt*4)))
# summary(mod.H1)
# 
# mod.H2 <- lm(x ~ I(sin(2*pi*tt*4)) + I(cos(2*pi*tt*4)) + I(sin(2*pi*tt*3.981567)) + I(cos(2*pi*tt*3.981567)))
# summary(mod.H2)
# 
# # Fitted values and residuals
# 
# x.fit <- mod.H1$fitted.values
# x.fit <- ts(x.fit,start=start(x),frequency=frequency(x))
# 
# points(x.fit,col="red",type="o",pch=16,cex=0.5)
# 
# r <- residuals(mod.H2)
# #ne delaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
```


3. TOČKA: Narišite graf rezidualov in komentirajte, ali so videti stacionarni. Stacionarnost tudi preizkusite z uporabo ustreznih statističnih metod.

```{r, echo=TRUE, eval=TRUE, results="markup",echo=FALSE}

# plot(x.res, main="Residuals")
# 
# summary(mod.H)$adj.r.squared
# 
# plot(x.res, main= 'Residuali časovne vrste A', ylab="Residuals",type='l')
# 
# abline(h=mean(x.res),col="blue")
# abline(h=c(mean(x.res)-sd(x.res),mean(x.res)+sd(x.res)),col="blue",lty="dotted")
# 
# 
# library(tseries)
# # Augmented Dickey-Fuller Test za preverjanje stacionarnosti
# adf.test(x.res,alternative="stationary")
# # we say: ro - 1 = gamma 
# # Ho : gamma = 0 -> random walk (not stationary)
# # H1 : gamma < 0 -> stationary series
# 
# # this test is only appropriate if we remove seasonal and trend component
# # result: we reject Ho, so series is stationary!
# 
# komentar <- paste('Augmented Dickey-Fuller Test ne zavrne stacionarnosti.')
# print(komentar)


```

```{r, echo=TRUE, eval=TRUE, results="markup",echo=FALSE}

plot(d.res, main="Residuals")

summary(mod.H2)$adj.r.squared

plot(d.res, main= 'Residuali časovne vrste A', ylab="Residuals",type='l')

abline(h=mean(d.res),col="blue")
abline(h=c(mean(d.res)-sd(d.res),mean(d.res)+sd(d.res)),col="blue",lty="dotted")


library(tseries)
# Augmented Dickey-Fuller Test za preverjanje stacionarnosti
adf.test(d.res,alternative="stationary")
# we say: ro - 1 = gamma 
# Ho : gamma = 0 -> random walk (not stationary)
# H1 : gamma < 0 -> stationary series

# this test is only appropriate if we remove seasonal and trend component
# result: we reject Ho, so series is stationary!

komentar <- paste('Augmented Dickey-Fuller Test ne zavrne stacionarnosti.')
print(komentar)


```

4. TOČKA: Na rezidualih naredite grafikona ACF in PACF in na njuni podlagi predlagajte vsaj en model vrste AR(p) ali MA(q).

```{r, echo=TRUE, eval=TRUE, results="markup",echo=FALSE}
library(forecast)

# #zelo slabo, to ne more biti okej?
# Acf(x.res, main = "Acf residuals")  
# Pacf(x.res, main = "Pacf residuals")

Acf(d.res, main = "Acf residuals") #MA(1)?
Pacf(d.res, main = "Pacf residuals") #no idea

#PREDLOG MODELA:
komentar <- paste('Brina, v tem delu mi gre na jok. No zdej ne več, sam še vedno nevem ker model bi predlagala zares iz teh slik.')
print(komentar)

```

5. TOČKA: Na podlagi Yule–Walkerjevih cenilk in kriterija AIC izberite najboljši model AR(p). Primerjajte ga z najboljšim modelom ARMA(p, q) za p + q ≤ 3 po kriteriju AIC (pozor: kriterij AIC je lahko definiran drugače od postopka do postopka). Če je videti smiselno, pa namesto tega uporabite model GARCH.

```{r, echo=TRUE, eval=TRUE, results="markup", echo=FALSE}
# # ==========
# # ARMA model
# # ==========
# ar(x.res, arg = "yule–walker", aic=TRUE)
# 
# #Primerjajte ga z najboljšim modelom ARMA(p,q)
# 
# # arima(x.res, order=c(1,0,1)) #aic = 10995.32
# # arima(x.res, order=c(1,0,0)) #aic = 11289.52
# # arima(x.res, order=c(0,0,1)) #aic = 11017.15
# # arima(x.res, order=c(2,0,1)) #aic = 9627.83
# # arima(x.res, order=c(1,0,2)) #aic = 10690.56
# # arima(x.res, order=c(2,0,0)) #aic = 9650.55
# # arima(x.res, order=c(0,0,2)) #aic = 10688.79
# arima(x.res, order=c(3,0,0)) #aic = 9597.9  - izberemo tega AR(3)
# # arima(x.res, order=c(0,0,3)) #aic = 10557.7
# 
# 
# #Če je videti smiselno, pa namesto tega uporabite model GARCH.
# 
# # AIC(garch(x.res, order = c(0,1))) #11272.1
# # AIC(garch(x.res, order = c(1,1))) #11254.5
# # AIC(garch(x.res, order = c(2,1))) #11254.5
# # AIC(garch(x.res, order = c(1,0))) #11271.52
# # AIC(garch(x.res, order = c(1,2))) #11123.97
# AIC(garch(x.res, order = c(0,3))) #11109.16 #izberemo tega
# # AIC(garch(x.res, order = c(3,0))) #11243.32
# 
# 
# #Brina, sanja se mi ne kaj je ta GARCH model :(
# #pa zgornje stvari sem zakomentirala, ker če ne vse izpiše v poročilu in je grdo
# 
# komentar <- paste('Izbrali sva model AR(3).')
# print(komentar)

```

```{r, echo=TRUE, eval=TRUE, results="markup", echo=FALSE}
# ==========
# ARMA model
# ==========
ar(d.res, arg = "yule–walker", aic=TRUE)

#Primerjajte ga z najboljšim modelom ARMA(p,q)

# arima(d.res, order=c(1,0,1)) #aic = 8917.23
# arima(d.res, order=c(1,0,0)) #aic = 9247.46
arima(d.res, order=c(0,0,1)) #aic = 8916.14
# arima(d.res, order=c(2,0,1)) #aic = 8918.38
# arima(d.res, order=c(1,0,2)) #aic = 8918.2
# arima(d.res, order=c(2,0,0)) #aic = 9149
# arima(d.res, order=c(0,0,2)) #aic = 8917.17
# arima(d.res, order=c(3,0,0)) #aic = 9094.19 
# arima(d.res, order=c(0,0,3)) #aic = 8918.41

#odločava se med: 1) AR(1) in MA(1), 
#                 2) MA(1),
#                 3) AR(2) in MA(1)
#                 4) AR(1) in MA(2)
#                 5) MA(2)
#                 6) MA(3)

#Če je videti smiselno, pa namesto tega uporabite model GARCH.

# AIC(garch(d.res, order = c(0,1))) #9401.772
# AIC(garch(d.res, order = c(1,1))) #9410.327
# AIC(garch(d.res, order = c(2,1))) #9397.403
# AIC(garch(d.res, order = c(1,0))) #9437.167
# AIC(garch(d.res, order = c(1,2))) #9397.488
# AIC(garch(d.res, order = c(0,3))) #9386.289 #izberemo tega?
# AIC(garch(d.res, order = c(3,0))) #9418.703


#Brina, sanja se mi ne kaj je ta GARCH model :(
#pa zgornje stvari sem zakomentirala, ker če ne vse izpiše v poročilu in je grdo

komentar <- paste('Izbrali sva model MA(1).')
print(komentar)

```


6. TOČKA: Izberite »optimalni« model in ocenite vse njegove parametre.

```{r, echo=TRUE, eval=TRUE, results="markup",echo=FALSE}
# OPTIMALNI MODEL: izberemo tisti model, ki ima najnižji aic. V najinem primeru je to AR(3). Druga možna izbira bi bila model z MA(1) in AR(2).
komentar <- paste('OPTIMALNI MODEL: izberemo tisti model, ki ima najnižji aic. V najinem primeru je to MA(1).')
print(komentar)

best <- arima(d.res, order=c(0,0,1))
plot(best$residuals)
hist(best$residuals)

#Normality test
shapiro.test(best$residuals) #p-value = 0.4167
#From the output, the p-value > 0.05 implying that the distribution of the data are not significantly different from normal distribution. In other words, we can assume the normality.

#plot the results to check the normality
xx <- seq(-300, 300, by=0.1)
y1 <- dnorm(xx, mean=mean(best$residuals), sd=(sd(best$residuals)))
plot(density(best$residuals),col="blue", main ="Normal density funcion comparison", xlab="x")
lines(xx,y1, col="red")
legend("topleft",
       c("Residual density","Normal function"),
       col=c("blue","red"),
       lty="solid",
       bty="n")

komentar <- paste('Shapirov test ne zavrne hipoteze, torej gre za normalno porazdelitev kar je očitno tudi iz grafa.')
print(komentar)
```


7. TOČKA: Oglejte si ostanke po vašem modelu in komentirajte, ali so videti kot beli šum. Primerjajte njihovo porazdelitev z normalno.
```{r, echo=TRUE, eval=TRUE, results="markup",echo=FALSE}
#odgovori
#Če je white noise nobena frekvenca ni dominantna. Bi mogel biti graf dokaj raven

plot(periodogram(best$residuals)$lambda, periodogram(best$residuals)$periodogram, type="l")


Box.test(d.res, lag = 1, type="Box-Pierce") #p-value < 2.2e-16
Box.test(d.res, lag = 1, type="Ljung-Box") #p-value < 2.2e-16


#The P-Value of the Ljung-Box white noise test is greater than significance level (i.e. α), so we don't reject the white noise hypothesis (Ho), or, simply stated; there is no statistical evidence of a serial correlation, so the data can be white noise.

komentar <- paste('Ne gre za white noise.')
print(komentar)

```

8. TOČKA: Z uporabo izbranega modela in pod predpostavko normalnosti z R-ovo funkcijo predict konstruirajte 90% napovedni interval za naslednjo vrednost. Ne pozabite vračunati tudi odstranjenega trenda in sezonskosti.

```{r, echo=TRUE, eval=TRUE, results="markup",echo=FALSE}

# TA DEL JE SKOR ZIHR NAROBE! Sem napisala ?? tja kamor nevem kaj bi napisala

# prediction <- predict(best, n.ahead = 1, interval = "prediction", level = 0.90)
# val1 <- prediction$pred[1]
# sd1 <- prediction$se[1]
# z <- 1.64
# 
# n <- length(d) + 1
# napoved <- ??? +  ??? *sin(perioda*n) + ??? * cos(perioda*n)
# naslednji <- napoved + val1
# optimal_interval <- c(napoved + val1 - z*sd1,napoved + val1+z*sd1)
# plot(append(naslednji, x)[???:???], type="l", main="Prediction", ylab="Value", col='red')
```

9. TOČKA: Dobljeni napovedni interval primerjajte z napovednim intervalom, ki bi ga dobili, če bi naivno privzeli, da so podatki kar Gaussov beli šum – pred in po odstranitvi trenda in sezonskosti.

```{r, echo=TRUE, eval=TRUE, results="markup", echo=FALSE}
# naive_gaussian <- mean(x)
# naive_gaussian_interval <- c(naive_gaussian - z*sd(x), naive_gaussian + z*sd(x))
# plot(append(x, naive_gaussian), type="l")
# 
# better_gaussian <- napoved + mean(x.res) + (sd(x.res)^2)/2
# 
# spodnja_meja <- napoved + mean(x.res) + (sd(x.res)^2)/2 - z * sqrt((sd(x.res))^2/length(x.res) + (sd(x.res)^4)/(2*(length(x.res)-1)))
# zgornja_meja <- napoved + mean(x.res) + (sd(x.res)^2)/2 + z * sqrt((sd(x.res))^2/length(x.res) + (sd(x.res)^4)/(2*(length(x.res)-1)))
# better_gaussian_interval <- c(spodnja_meja, zgornja_meja)
# 
# plot(append(x, better_gaussian), type="l", xlim=c(700,850))
# plot(append(x, naslednji), type="l", xlim=c(700,850))
# plot(append(x, naive_gaussian), type="l", xlim=c(700,850))
# plot(append(x, better_gaussian), type="l", xlim=c(700,850))

```



<h1> DATOTEKA B </h1>


1. *Narišite graf in komentirajte, ali se iz njega vidi kakšen trend ali sezonskost.*
```{r, echo=TRUE, eval=TRUE, results="markup",echo=FALSE}
file2 <- file("B09los.txt")
str_data2 <- readLines(file2)
data2 <- as.numeric(unlist(strsplit(str_data2, " ")))
x <- ts(data2)

# vsa opazovanja:
plot(x, main="Časovna vrsta podatki b, vsa opazovanja", type='l')

komentar <- paste('Opazimo trend, na prvi pogled ne opazimo sezonskosti.')
print(komentar)

```

2. *Odstranite morebiten trend in sezonskost z metodami, uporabljenimi pri tečaju: (zaporedno) diferenciranje, logaritmiranje, neposredna ocena sezonskih komponent, polinomski trend stopnje največ 3 ali prileganje periodične funkcije (ali kakšna kombinacija teh metod). Potem ko odstranite morebiten trend, narišite tudi surovi in zglajeni periodogram ter komentirajte, ali se vidi kakšna sezonskost in kakšna naj bi bila perioda.*


Logaritmiranja ne moremo uporabiti, ker imamo negativne podatke. Uporabimo
diferenciranje:

```{r, echo=TRUE, eval=TRUE, results="markup",echo=FALSE}
#Opazujmo diference
d <- diff(x)
plot(d, main='Diference časovne vrste B', xlim = c(0,100), ylab=expression(paste(nabla,x[t]," [pp]")),type='l')

abline(h=mean(d),col="blue")
abline(h=c(mean(d)-sd(d),mean(d)+sd(d)),col="blue",lty="dotted")

perioda <-  periodogram(d)$lambda[which.max(periodogram(d)$periodogram)] 

t <- time(d)
mod.H2 <- lm(d ~  I(sin(perioda*t)) + I(cos(perioda*t)))
summary(mod.H2)

d.fit <- mod.H2$fitted.values
d.res <- mod.H2$residuals

d.fit <- ts(d.fit,start=start(d),frequency=frequency(d))
d.res <- ts(d.res,start=start(d),frequency=frequency(d))

par(mfrow=c(1,1))
plot(d, type='l')
points(d.fit,col="red",type="o",pch=16,cex=0.5)
par(mfrow=c(1,1))
plot(d, type='l', xlim=c(50,150))
points(d.fit,col="red",type="o",pch=16,cex=0.5)

```


3. *Narišite graf rezidualov in komentirajte, ali so videti stacionarni. Stacionarnost tudi preizkusite z uporabo ustreznih statističnih metod.*

```{r, echo=TRUE, eval=TRUE, results="markup",echo=FALSE}

# plot(x.res, main="Residuals")
# 
# summary(mod.H)$adj.r.squared
# 
# plot(x.res, main= 'Residuali časovne vrste A', ylab="Residuals",type='l')
# 
# abline(h=mean(x.res),col="blue")
# abline(h=c(mean(x.res)-sd(x.res),mean(x.res)+sd(x.res)),col="blue",lty="dotted")
# 
# 
# library(tseries)
# # Augmented Dickey-Fuller Test za preverjanje stacionarnosti
# adf.test(x.res,alternative="stationary")
# # we say: ro - 1 = gamma 
# # Ho : gamma = 0 -> random walk (not stationary)
# # H1 : gamma < 0 -> stationary series
# 
# # this test is only appropriate if we remove seasonal and trend component
# # result: we reject Ho, so series is stationary!
# 
# komentar <- paste('Augmented Dickey-Fuller Test ne zavrne stacionarnosti.')
# print(komentar)


```

```{r, echo=TRUE, eval=TRUE, results="markup",echo=FALSE}

plot(d.res, main="Residuals")

summary(mod.H2)$adj.r.squared

plot(d.res, main= 'Residuali časovne vrste A', ylab="Residuals",type='l')

abline(h=mean(d.res),col="blue")
abline(h=c(mean(d.res)-sd(d.res),mean(d.res)+sd(d.res)),col="blue",lty="dotted")


library(tseries)
# Augmented Dickey-Fuller Test za preverjanje stacionarnosti
adf.test(d.res,alternative="stationary")
# we say: ro - 1 = gamma 
# Ho : gamma = 0 -> random walk (not stationary)
# H1 : gamma < 0 -> stationary series

# this test is only appropriate if we remove seasonal and trend component
# result: we reject Ho, so series is stationary!

#p-value = 0.01

komentar <- paste('Augmented Dickey-Fuller Test ne zavrne stacionarnosti.')
print(komentar)


```

4. *Na rezidualih naredite grafikona ACF in PACF in na njuni podlagi predlagajte vsaj en model vrste AR(p) ali MA(q).*

```{r, echo=TRUE, eval=TRUE, results="markup",echo=FALSE}
library(forecast)

# #zelo slabo, to ne more biti okej?
# Acf(x.res, main = "Acf residuals")  
# Pacf(x.res, main = "Pacf residuals")

Acf(d.res, main = "Acf residuals") #MA(1)?
Pacf(d.res, main = "Pacf residuals") #no idea

#PREDLOG MODELA:
komentar <- paste('MA(1)??')
print(komentar)

```

5. *Na podlagi Yule–Walkerjevih cenilk in kriterija AIC izberite najboljši model AR(p). Primerjajte ga z najboljšim modelom ARMA(p, q) za p + q ≤ 3 po kriteriju AIC (pozor: kriterij AIC je lahko definiran drugače od postopka do postopka). Če je videti smiselno, pa namesto tega uporabite model GARCH.*

```{r, echo=TRUE, eval=TRUE, results="markup", echo=FALSE}
# ==========
# ARMA model
# ==========
ar(d.res, arg = "yule–walker", aic=TRUE)

#Primerjajte ga z najboljšim modelom ARMA(p,q)

# arima(d.res, order=c(1,0,1)) #aic = 2515.59
# arima(d.res, order=c(1,0,0)) #aic = 2586.78
arima(d.res, order=c(0,0,1)) #aic = 2513.86 #dejva tega :D
# arima(d.res, order=c(2,0,1)) #aic = 2516.07
# arima(d.res, order=c(1,0,2)) #aic = 2517.38
# arima(d.res, order=c(2,0,0)) #aic = 2540.85
# arima(d.res, order=c(0,0,2)) #aic = 2515.54
# arima(d.res, order=c(3,0,0)) #aic = 2528.42
# arima(d.res, order=c(0,0,3)) #aic = 2516.6

#odločava se med: 1) AR(1) in MA(1), 
#                 2) MA(1),
#                 3) AR(2) in MA(1)
#                 4) AR(1) in MA(2)
#                 5) MA(2)
#                 6) MA(3)

komentar <- paste('Izbrali sva model MA(1).')
print(komentar)

```


6. *Izberite »optimalni« model in ocenite vse njegove parametre.*

```{r, echo=TRUE, eval=TRUE, results="markup",echo=FALSE}
# OPTIMALNI MODEL: izberemo tisti model, ki ima najnižji aic. V najinem primeru je to AR(3). Druga možna izbira bi bila model z MA(1) in AR(2).
komentar <- paste('OPTIMALNI MODEL: izberemo tisti model, ki ima najnižji aic. V najinem primeru je to MA(1).')
print(komentar)

best <- arima(d.res, order=c(0,0,1))
plot(best$residuals)
hist(best$residuals)

#Normality test
shapiro.test(best$residuals) #p-value = 0.01096
#From the output, the p-value > 0.05 implying that the distribution of the data are not significantly different from normal distribution. In other words, we can assume the normality.

#plot the results to check the normality
xx <- seq(-100, 100, by=0.1)
y1 <- dnorm(xx, mean=mean(best$residuals), sd=(sd(best$residuals)))
plot(density(best$residuals),col="blue", main ="Normal density funcion comparison", xlab="x")
lines(xx,y1, col="red")
legend("topleft",
       c("Residual density","Normal function"),
       col=c("blue","red"),
       lty="solid",
       bty="n")

komentar <- paste('Shapirov test zavrne hipotezo, torej ne gre za normalno porazdelitev. MOJ KOMENTAR: meni se zdi to zelo normalno?')
print(komentar)
```


7. *Oglejte si ostanke po vašem modelu in komentirajte, ali so videti kot beli šum. Primerjajte njihovo porazdelitev z normalno.*
```{r, echo=TRUE, eval=TRUE, results="markup",echo=FALSE}
#odgovori
#Če je white noise nobena frekvenca ni dominantna. Bi mogel biti graf dokaj raven

plot(periodogram(best$residuals)$lambda, periodogram(best$residuals)$periodogram, type="l")


Box.test(d.res, lag = 1, type="Box-Pierce") #p-value = 7.216e-15
Box.test(d.res, lag = 1, type="Ljung-Box") #p-value = 4.996e-15


#The P-Value of the Ljung-Box white noise test is greater than significance level (i.e. α), so we don't reject the white noise hypothesis (Ho), or, simply stated; there is no statistical evidence of a serial correlation, so the data can be white noise.

komentar <- paste('Ne gre za white noise.')
print(komentar)

```

8. *Z uporabo izbranega modela in pod predpostavko normalnosti z R-ovo funkcijo predict konstruirajte 90% napovedni interval za naslednjo vrednost. Ne pozabite vračunati tudi odstranjenega trenda in sezonskosti.*

```{r, echo=TRUE, eval=TRUE, results="markup",echo=FALSE}

# TA DEL JE SKOR ZIHR NAROBE! Sem napisala ?? tja kamor nevem kaj bi napisala

# prediction <- predict(best, n.ahead = 1, interval = "prediction", level = 0.90)
# val1 <- prediction$pred[1]
# sd1 <- prediction$se[1]
# z <- 1.64
# 
# n <- length(d) + 1
# napoved <- ??? +  ??? *sin(perioda*n) + ??? * cos(perioda*n)
# naslednji <- napoved + val1
# optimal_interval <- c(napoved + val1 - z*sd1,napoved + val1+z*sd1)
# plot(append(naslednji, x)[???:???], type="l", main="Prediction", ylab="Value", col='red')
```

9. *Dobljeni napovedni interval primerjajte z napovednim intervalom, ki bi ga dobili, če bi naivno privzeli, da so podatki kar Gaussov beli šum – pred in po odstranitvi trenda in sezonskosti.*

```{r, echo=TRUE, eval=TRUE, results="markup", echo=FALSE}
# naive_gaussian <- mean(x)
# naive_gaussian_interval <- c(naive_gaussian - z*sd(x), naive_gaussian + z*sd(x))
# plot(append(x, naive_gaussian), type="l")
# 
# better_gaussian <- napoved + mean(x.res) + (sd(x.res)^2)/2
# 
# spodnja_meja <- napoved + mean(x.res) + (sd(x.res)^2)/2 - z * sqrt((sd(x.res))^2/length(x.res) + (sd(x.res)^4)/(2*(length(x.res)-1)))
# zgornja_meja <- napoved + mean(x.res) + (sd(x.res)^2)/2 + z * sqrt((sd(x.res))^2/length(x.res) + (sd(x.res)^4)/(2*(length(x.res)-1)))
# better_gaussian_interval <- c(spodnja_meja, zgornja_meja)
# 
# plot(append(x, better_gaussian), type="l", xlim=c(700,850))
# plot(append(x, naslednji), type="l", xlim=c(700,850))
# plot(append(x, naive_gaussian), type="l", xlim=c(700,850))
# plot(append(x, better_gaussian), type="l", xlim=c(700,850))

```
